---
import Default from '@astrojs/starlight/components/PageFrame.astro'
import type { Props } from '@astrojs/starlight/props'

// TODO(HiDeoo) Move to pageframe? Remove the single instance check?

// TODO(HiDeoo) only certain page?
// TODO(HiDeoo) control banner
// TODO(HiDeoo) mobile/responsive
// TODO(HiDeoo) click = link to doc for specific override
// TODO(HiDeoo) click = copy name?
// TODO(HiDeoo) click = modal containing everything with an example and everything?
---

<starlight-override-map>
  <div class="starlight-override-map-toolbar">
    <label><input type="checkbox" />Enabled</label>
  </div>
</starlight-override-map>
<Default {...Astro.props}><slot slot="header" name="header" /><slot /><slot slot="sidebar" name="sidebar" /></Default>

<style is:global>
  :root {
    --starlight-override-map-toolbar-height: 3rem;
    --starlight-override-map-accent-color: hsl(347 77% 50%);
  }

  :root[data-theme='light'] {
    --starlight-override-map-accent-color: hsl(345 83% 41%);
  }

  header.header {
    inset-block-start: var(--starlight-override-map-toolbar-height);
  }

  .sidebar-pane {
    inset-block-start: calc(var(--sl-nav-height) + var(--starlight-override-map-toolbar-height));
  }

  .main-frame {
    padding-top: calc(
      var(--sl-nav-height) + var(--sl-mobile-toc-height) + var(--starlight-override-map-toolbar-height)
    );
  }

  @media (min-width: 72rem) {
    aside .right-sidebar {
      padding-top: calc(var(--sl-nav-height) + var(--starlight-override-map-toolbar-height));
    }
  }

  mobile-starlight-toc nav {
    top: calc(var(--sl-nav-height) - 1px + var(--starlight-override-map-toolbar-height));
  }

  starlight-menu-button button {
    top: calc(((var(--sl-nav-height) - var(--sl-menu-button-size)) / 2) + var(--starlight-override-map-toolbar-height));
  }

  body > a[href='#_top'] {
    top: calc(0.75rem + var(--starlight-override-map-toolbar-height));
  }
</style>

<style>
  .starlight-override-map-toolbar {
    align-items: center;
    background-color: var(--starlight-override-map-accent-color);
    color: white;
    display: flex;
    height: var(--starlight-override-map-toolbar-height);
    inset-inline: 0;
    padding-inline: 1.5rem;
    position: fixed;
    z-index: 90;
  }
</style>

<script>
  const overrides: Override[] = [
    // FIXME(HiDeoo) Head
    // FIXME(HiDeoo) Accessibility
    // Layout
    { name: 'PageFrame', selector: '.page', offset: { block: [-50, -2], inline: -2 } },
    { name: 'MobileMenuToggle', selector: 'button[aria-controls="starlight__sidebar"]', offset: 10 },
    { name: 'TwoColumnContent', selector: '.lg\\:sl-flex' },
    // Header
    { name: 'Header', selector: 'header.header', offset: -2 },
    { name: 'SiteTitle', selector: '.site-title', offset: { inline: 8 } },
    { name: 'Search', selector: 'site-search button', offset: 6 },
    // TODO(HiDeoo) search modal?
    // TODO(HiDeoo) SocialIcons
    { name: 'ThemeSelect', selector: 'starlight-theme-select label', offset: { inline: 8 } },
    { name: 'LanguageSelect', selector: 'starlight-lang-select label', offset: { inline: 8 } },
    // Global Sidebar
    { name: 'Sidebar', selector: '.sidebar-content', offset: -2 },
    { name: 'MobileMenuFooter', selector: '.mobile-preferences', offset: { inline: 6 } },
    // Page Sidebar
    { name: 'PageSidebar', selector: '.right-sidebar', offset: { block: [-113, -2] } },
    { name: 'TableOfContents', selector: 'starlight-toc', offset: 8 },
    { name: 'MobileTableOfContents', selector: 'mobile-starlight-toc nav' },
    // Content
    { name: 'Banner', selector: '.sl-banner' },
    { name: 'ContentPanel', selector: '.content-panel' },
    { name: 'PageTitle', selector: 'h1#_top', offset: { inline: 8 } },
    { name: 'DraftContentNotice', selector: 'h1#_top + p', offset: 4 },
    { name: 'FallbackContentNotice', selector: 'h1#_top + p + p', offset: 4 },
    { name: 'Hero', selector: '.hero', offset: { block: 4, inline: 8 } },
    { name: 'MarkdownContent', selector: '.sl-markdown-content', offset: 12 },
    // Footer
    { name: 'Footer', selector: 'footer', offset: 8 },
    { name: 'LastUpdated', selector: 'footer .meta > p', offset: 8 },
    { name: 'EditLink', selector: 'footer .meta > a', offset: 8 },
    { name: 'Pagination', selector: '.pagination-links', offset: 8 },
  ]

  customElements.define(
    'starlight-override-map',
    class StarlightOverrideMap extends HTMLElement {
      // FIXME(HiDeoo) switch to disabled by default
      #enabled = true
      #highlight: HTMLDivElement | undefined
      #tooltip: HTMLDivElement | undefined

      constructor() {
        super()

        this.#createOverlay()
        this.#registerListeners()

        this.querySelector('input')?.addEventListener('change', (event) => {
          if (!(event.target instanceof HTMLInputElement)) return
          this.#enabled = event.target.checked
        })
      }

      #registerListeners() {
        const inEvents = ['focus', 'mouseover'] as const
        const outEvents = ['blur', 'mouseout'] as const

        for (const override of overrides) {
          const elements = document.querySelectorAll(override.selector)

          for (const element of elements) {
            for (const event of inEvents) {
              element.addEventListener(event, () => this.#showOverlay(override, element), { capture: true })
            }

            for (const event of outEvents) {
              element.addEventListener(event, () => this.#hideOverlay())
            }
          }
        }
      }

      #createOverlay() {
        this.#highlight = document.createElement('div')
        this.#highlight.style.border = `2px dashed var(--starlight-override-map-accent-color)`
        this.#highlight.style.display = 'none'
        this.#highlight.style.pointerEvents = 'none'
        this.#highlight.style.position = 'absolute'
        this.#highlight.style.zIndex = '100'

        this.#tooltip = document.createElement('div')
        this.#tooltip.style.backgroundColor = 'var(--starlight-override-map-accent-color)'
        this.#tooltip.style.color = 'white'
        this.#tooltip.style.display = 'none'
        this.#tooltip.style.padding = '0.375rem 0.625rem'
        this.#tooltip.style.pointerEvents = 'none'
        this.#tooltip.style.position = 'absolute'
        this.#tooltip.style.zIndex = '101'

        document.body.append(this.#highlight)
        document.body.append(this.#tooltip)
      }

      #showOverlay(override: Override, element: Element) {
        if (!this.#enabled) return
        if (!this.#highlight || !this.#tooltip) return
        const rect = element.getBoundingClientRect()
        const topOffset = this.#getOffsetValue(override.offset, 'top')
        const bottomOffset = this.#getOffsetValue(override.offset, 'bottom')
        const leftOffset = this.#getOffsetValue(override.offset, 'left')
        const rightOffset = this.#getOffsetValue(override.offset, 'right')
        // This is a bit fragile so probably a good refactor candidate.
        const isTooltipInside = rect.height < 100

        this.#highlight.style.top = `${rect.top + window.scrollY - topOffset}px`
        this.#highlight.style.left = `${rect.left + window.scrollX - leftOffset}px`
        this.#highlight.style.width = `${rect.width + leftOffset + rightOffset}px`
        this.#highlight.style.height = `${rect.height + topOffset + bottomOffset}px`
        this.#highlight.style.display = 'block'

        this.#tooltip.style.top = isTooltipInside
          ? `${rect.top + window.scrollY + rect.height + topOffset - 2}px`
          : `${rect.top + window.scrollY - topOffset}px`
        this.#tooltip.style.left = `${rect.left + window.scrollX - leftOffset}px`
        this.#tooltip.style.right = 'auto'
        this.#tooltip.style.display = 'block'
        this.#tooltip.textContent = override.name

        const tooltipRect = this.#tooltip.getBoundingClientRect()

        if (tooltipRect.right > window.innerWidth) {
          this.#tooltip.style.left = 'auto'
          this.#tooltip.style.right = `${window.innerWidth - rect.right - rightOffset}px`
        }

        if (tooltipRect.bottom > window.innerHeight) {
          this.#tooltip.style.top = isTooltipInside
            ? `${rect.top + window.scrollY - tooltipRect.height - topOffset + 2}px`
            : `${rect.top + window.scrollY - tooltipRect.height - topOffset}px`
        }
      }

      #hideOverlay() {
        if (!this.#tooltip || !this.#highlight) return

        this.#highlight.style.display = 'none'
        this.#tooltip.style.display = 'none'
      }

      #getOffsetValue(offset: Offset | undefined, direction: 'top' | 'bottom' | 'left' | 'right') {
        if (offset === undefined) return 0
        if (typeof offset === 'number') return offset

        const logicalDirection = direction === 'top' || direction === 'bottom' ? 'block' : 'inline'
        const directionIndex = direction === 'top' || direction === 'left' ? 0 : 1

        return typeof offset[logicalDirection] === 'number'
          ? offset[logicalDirection]
          : (offset[logicalDirection]?.[directionIndex] ?? 0)
      }
    },
  )

  interface Override {
    name: string
    offset?: Offset
    selector: string
  }

  // In pixels
  type Offset =
    | number
    | {
        block?: number | [top: number, bottom: number]
        inline?: number | [left: number, right: number]
      }
</script>
